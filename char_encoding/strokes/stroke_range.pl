#!/usr/bin/perl
#
# 在 data section 是 big5 範圍和筆劃的對應表,
# build_table() 會讀取 data 並將資料存在 @array 這個表格內
# 每一個 array 內的元素代表 (「最小值」、「最大值」、「筆劃數」)
# lookup_table() 將查詢表格，找不到傳回 0
#
# todo: use another source of big5 char table to cross-reference

use strict;
use warnings;

use Data::Dump qw(dump);

my @array = ();

# [in] ''f1eb-f3fc''
# return min, max
sub parse_two($)
{
	my $str = shift;
	my ($min, $max) = ( $str =~ m/(....)-(....)/ );

	return (hex($min), hex($max));
}

# read __DATA__ and put parsed data into ''@array''
sub build_stroke_table()
{
	my $debug = 0;
	my $count = 0;
	my ($t1, $t2) = ();

	while (<DATA>)  {
		next if /^#/;
		next if /^$/;

		++ $count;
		my ($num, $p1, $p2, $p3) =
			( m/(\d\d)\t								# first number: strokes
				([A-Za-z0-9]{4}-[A-Za-z0-9]{4})\t?		# common part #1 (always)
				([A-Za-z0-9]{4}-[A-Za-z0-9]{4})?\t?		# common part #2 (optional)
				([A-Za-z0-9]{4}-[A-Za-z0-9]{4})?$/x		# common part #3 (optional)
			);

		print "num($num)\t" if $num && $debug;
		if ($p1)  {
			print "p1($p1)\t" if $debug;
			($t1, $t2) = parse_two($p1);
			push @array, [$t1, $t2, $num];
		}
		if ($p2)  {
			print "p2($p2)\t" if $debug;
			($t1, $t2) = parse_two($p2);
			push @array, [$t1, $t2, $num];
		}
		if ($p3)  {
			print "p3($p3)\t" if $debug;
			($t1, $t2) = parse_two($p3);
			push @array, [$t1, $t2, $num];
		}
		print "\n" if $debug;
	}
	print "count => $count\n";
	dump(@array) if $debug;
}

# each element of array: [min, max, num]
sub lookup_table($)
{
	my $val = shift;
	my $found = 0;
	my $debug = 0;

	for my $k (@array)  {
		#dump($k);
		#my ($min, $max, $num) = @$k;
		#print "($min, $max, $num)\n";
		if ($val >= $$k[0] && $val <= $$k[1])  {
			$found = 1;
			#print "in range => ($min, $max, $num)\n";
			print STDERR "in range => ($$k[0], $$k[1], $$k[2])\n" if $debug;
			#return $num;
			return $$k[2];
		}
	}
	return $found;
}

sub output_big5($)
{
	my $str = shift;

	my ($hi, $lo) = ( $str =~ m/0x(..)(..)/ );
	$str = chr(hex($hi)) . chr(hex($lo));
	return $str;
}

#
# main procedure here
#
sub main
{
	build_stroke_table();
	print STDERR "build table finished\n";

	# the first column of ''big5file'' is 0xABCD big5 code
	my $ifile = 'big5_2003-b2u.txt';	# 'big5_2003_uni.txt'
	my $ofile = 'stroke_range.txt';

	print STDERR "input: $ifile\noutput: $ofile\n";

	open my $ifh, "< $ifile" or die;
	open my $ofh, "> $ofile" or die;
	binmode $ofh;

	my $stroke = 0;
	my $icount = 0;
	my $fcount = 0;
	my $ch;

	print $ofh "# generated by $0\n", "# big5 unicode big5_char strokes\n";
	while (<$ifh>)  {
		next if m/^#/;
		next if m/^$/;

		++ $icount;
		my $line = $_;
		my ( $big5 ) = ( m/^(0x[a-fA-F0-9]{4})/ );

		$line =~ s/[\r\n]//;
		$stroke = lookup_table(hex($big5));
		$ch = output_big5($big5);

		if ($stroke > 0)  {
			printf $ofh "%s\t%s\t%d\n", $line, $ch, $stroke;
			++ $fcount;
		}
		print STDERR "$fcount / $icount\r";
	}

	close $ifh;
	close $ofh;
}

main;

__DATA__
# strokes ..... range01
01	A440-A441
02	A442-A453	C940-C944
03	A454-A47E	C945-C94C
04	A4A1-A4FD	C94D-C95C
05	A4FE-A5DF	C95D-C9AA
06	A5E0-A6E9	C9AB-C959
07	A6EA-A8C2	CA5A-CBB0
08	A8C3-AB44	CBB1-CDDC
09	AB45-ADBB	CDDD-D0C7	F9DA-f9da
10	ADBC-B0AD	D0C8-D44A
11	B0AE-B3C2	D44B-D850
12	B3C3-B6C3	D851-DCB0	F9DB-fadb
13	B6C4-B9AB	DCB1-E0EF	F9D6-F9D8
14	B9AC-BBF4	E0F0-E4E5
15	BBF5-BEA6	E4E6-E8F3	F9DC-f9dc
16	BEA7-C074	E8F4-ECB8	F9D9-f9d9
17	C075-C24E	ECB9-EFB6
18	C24F-C35E	EFB7-F1EA
19	C35F-C454	F1EB-F3FC
20	C455-C4D6	F3FD-F5BF
21	C3D7-C56A	F5C0-F6D5
22	C56B-C5C7	F6D6-F7CF
23	C5C8-C5C7	F6D6-F7CF
24	C5F1-C654	F8A5-F8ED
25	C655-C664	F8E9-F96A
26	C665-C66B	F96B-F9A1
27	C66C-C675	F9A2-F9B9
28	C676-C67A	F9BA-F9C5
29	C67B-C67E	F9C6-F9DC
