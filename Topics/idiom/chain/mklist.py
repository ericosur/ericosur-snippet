#!/usr/bin/env python3
#coding: utf-8

'''
four-character idioms to do word chain (han character, not bopomofo)

for example:

一五一十
十全十美
美不勝收
...

'''

import sys
from random import randint
#from rich.console import Console
from loguru import logger
from pydantic import BaseModel
sys.path.insert(0, "../")
from idiom_list import IDIOM_BOPOMOFO as the_idioms  # type: ignore[import]

class IdiomStruct(BaseModel):
    ''' 4 character idiom into three parts'''
    no: int
    full: str
    head: str
    body: str
    tail: str
    bpmf: str

# console = Console()
# logd = console.log
logd = logger.debug

class IdiomWordChain():
    ''' pick some idioms from list '''
    def __init__(self):
        self.idioms = []
        self.__prepare()
        self.head_dict = {}
        self.tail_dict = {}

    def __prepare(self):
        ''' prepare '''
        cnt = 0
        logd(f'total input idioms: {len(the_idioms)}')
        for t in the_idioms:
            if len(t[0]) == 4:
                s = t[0]  # the full idiom string
                t = IdiomStruct(no=cnt, full=s, head=s[0], body=s[1:3], tail=s[-1], bpmf=t[1])
                cnt += 1
                self.idioms.append(t)
        logd(f'after grep (only 4-char idioms kept): {len(self.idioms)}')
        #self.dump_to_text(self.idioms, '_idioms.py')
        logd(f'here is the last line of self.idioms: {self.idioms[-1]}')
        self.dump_idioms()

    def dump_idioms(self):
        ''' dump idioms '''
        with open('_idioms.py', "wt", encoding="UTF-8") as fobj:
            msg = '''
# coding:utf-8
"""
_idioms.py: generated by dump_idioms of mklist.py
"""
# pylint: disable=too-many-lines
the_list = ['''
            print(msg, file=fobj)
            once = False
            for i in self.idioms:
                if once is False:
                    logd(f'only the 1st line: {i}')
                    once = True
                print(f'"{i.full}",  # {i.no}', file=fobj)
            print(']', file=fobj)
        logd('output to: _idioms.py')

    def dump_i2d(self):
        ''' dump idioms to dict '''
        with open('_i2d.py', "wt", encoding="UTF-8") as fobj:
            msg = '''
# coding:utf-8
"""
_i2d.py: generated by dump_idioms of mklist.py
"""
# pylint: disable=line-too-long
the_dict = {'''
            print(msg, file=fobj)
            #t = IdiomStruct(no=cnt, full=I, head=I[0], body=I[1:3], tail=I[-1], bpmf=t[1])
            for i in self.idioms:
                print(f'    "{i.no}": ["{i.full}", "{i.head}", "{i.tail}"],', file=fobj)
            print('}', file=fobj)
        logd('output to: _i2d.py')

    def demo(self):
        ''' demo'''
        logd('pick from idioms')
        max_n = len(self.idioms)
        rep = 10
        for _ in range(rep):
            idx = randint(0, max_n-1)
            logd(f'{self.idioms[idx]}')

    def read_heads(self):
        ''' read heads '''
        fn = 'heads.txt'
        heads = []
        with open(fn, 'rt', encoding='UTF-8') as fobj:
            for ln in fobj.readlines():
                ln = ln.strip()
                m = ln.split(',')
                heads.append(m)
        return heads

    def check_tail_in_heads(self):
        ''' check key of tail_dict not in head_dicts '''
        tail_dict_cnt = 0
        not_in_head_cnt = 0
        not_in_head = []
        logd(f'{len(self.tail_dict)=}')
        logd(f'first item of tail_dict: {list(self.tail_dict.items())[0]}')
        for k in self.tail_dict:
            tail_dict_cnt += 1
            if k not in self.head_dict:
                not_in_head_cnt += 1
                #logd(f'{k} not in head_dict')
                not_in_head.append(k)
        assert tail_dict_cnt == len(self.tail_dict)
        logd(f'{not_in_head_cnt=}')
        # output not_in_head to _bads.txt
        logd(f'the last 5 items in not_in_head: {not_in_head[-5:]}')
        not_for_first = []
        try:
            once = False
            for k in not_in_head:
                if once is False:
                    logd(f'only the 1st line: {k=}: {self.tail_dict[k]}')
                    once = True
                not_for_first.extend(self.tail_dict[k])
        except ValueError:
            logd('out of bound: not_in_head')
        # dump too_bad.txt
        fn = 'too_bad.txt'
        with open(fn, 'wt', encoding='UTF-8') as fobj:
            for i in not_for_first:
                print(self.idioms[i].full, file=fobj)
                #logd(f'{i=}: {self.idioms[i].full}')
        logd(f'output to: {fn}')

    def do_check(self):
        ''' do check: collect to heads and tails '''
        heads = []
        tails = []
        for i in self.idioms:
            h = (i.no, i.head, i.full)
            heads.append(h)
            t = (i.no, i.tail, i.full)
            tails.append(t)
        self.head_dict = self.check_heads(heads)
        self.tail_dict = self.check_tails(tails)

    def check_heads(self, heads: list) -> dict:
        ''' check heads '''
        head_dict = {}
        for i in heads:
            k = i[1]
            v = i[0]
            if k not in head_dict:
                head_dict[k] = [v]
            else:
                if v not in head_dict[k]:
                    head_dict[k].append(v)
        logd(f'{len(head_dict)=}')
        return head_dict

    def check_tails(self, tails: list) -> dict:
        ''' check tails '''
        tail_dict = {}
        for i in tails:
            k = i[1]
            v = i[0]
            if k not in tail_dict:
                tail_dict[k] = [v]
            else:
                if v not in tail_dict[k]:
                    tail_dict[k].append(v)
        logd(f'{len(tail_dict)=}')
        return tail_dict

    def dump_dict(self, the_dict: dict, fn: str):
        ''' dump to text file '''
        with open(fn, "wt", encoding="UTF-8") as fobj:
            msg = '''# coding:utf-8
"""
generated by dump_dict of mklist.py
"""

# pylint: disable=too-many-lines
# pylint: disable=line-too-long
idiom_dict = {'''
            print(msg, file=fobj)
            #once = False
            for k,v in the_dict.items():
                # if once is False:
                #     logd(f'only the 1st line: {k=}, {v=}')
                #     once = True
                print(f'    "{k}": {v},', file=fobj)
            print('}', file=fobj)
        logd(f'output to: {fn}')

    @classmethod
    def run(cls):
        ''' run me '''
        obj = cls()
        obj.action()

    def action(self):
        ''' action '''
        logd('hello world')
        #logd(f'idioms: {len(self.idioms)}')
        self.do_check()
        self.check_tail_in_heads()
        #self.dump_dict(self.head_dict, '_heads.py')

if __name__ == "__main__":
    logd(sys.argv[0])
    IdiomWordChain.run()
